<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>polycore</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="nowrap">
  <li><strong>widget.lua</strong></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/cairo_helpers.lua.html">cairo_helpers.lua</a></li>
  <li><a href="../source/util.lua.html">util.lua</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/widget.html">widget</a></li>
  <li><a href="../modules/data.html">data</a></li>
  <li><a href="../modules/cairo_helpers.html">cairo_helpers</a></li>
  <li><a href="../modules/util.html">util</a></li>
</ul>

</div>

<div id="content">

    <h2>widget.lua</h2>
<pre>
<span class="comment">--- A collection of Widget classes
</span><span class="comment">-- @module widget
</span>
<span class="keyword">local</span> data = <span class="global">require</span> <span class="string">'data'</span>
<span class="keyword">local</span> util = <span class="global">require</span> <span class="string">'util'</span>
<span class="keyword">local</span> ch = <span class="global">require</span> <span class="string">'cairo_helpers'</span>

<span class="comment">--- Root widget wrapper
</span><span class="comment">-- Takes care of managing layout reflows and background caching.
</span><span class="comment">-- @type WidgetRenderer
</span><span class="keyword">local</span> WidgetRenderer = util.class()

<span class="comment">---
</span><span class="comment">-- @tparam table args table of options
</span><span class="comment">-- @tparam Widget args.root The Widget subclass that should be rendered,
</span><span class="comment">--                          usually a WidgetGroup
</span><span class="comment">-- @int args.width Width of the surface that should be covered
</span><span class="comment">-- @int args.height Height of the surface that should be covered
</span><a id="20"></a><span class="comment">-- @int args.padding Distance to be left clear on all sides of the surface
</span><span class="keyword">function</span> WidgetRenderer:init(args)
    self.root = args.root
    self.width = args.width
    self.height = args.height
    self.padding = args.padding
    self._background_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
                                                          args.width,
                                                          args.height)
<span class="keyword">end</span>

<span class="comment">--- Layout all Widgets and cache their backgrounds.
</span><span class="comment">-- Call this once to create the initial layout.
</span><a id="33"></a><span class="comment">-- Will be called again automatically each time the layout changes.
</span><span class="keyword">function</span> WidgetRenderer:layout()
    <span class="global">print</span>(<span class="string">"layout reflow…"</span>)
    self.root:layout(self.width - <span class="number">2</span> * self.padding)

    <span class="keyword">local</span> cr = cairo_create(self._background_surface)

    <span class="comment">-- clear surface
</span>    cairo_save (cr)
    cairo_set_source_rgba(cr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)
    cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE)
    cairo_paint(cr)
    cairo_restore(cr)

    <span class="keyword">if</span> DEBUG <span class="keyword">then</span>
        cairo_set_source_rgba(cr, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)
        cairo_select_font_face(cr, <span class="string">"Ubuntu"</span>, CAIRO_FONT_SLANT_NORMAL,
                                             CAIRO_FONT_WEIGHT_NORMAL)
        cairo_set_font_size(cr, <span class="number">8</span>)
        ch.write_left(cr, <span class="number">0</span>, <span class="number">8</span>, <span class="global">table</span>.concat{<span class="string">"conky "</span>, conky_version, <span class="string">" "</span>, _VERSION})
    <span class="keyword">end</span>

    cairo_translate(cr, self.padding, self.padding)
    self.root:render_background(cr)
    cairo_destroy(cr)
<span class="keyword">end</span>

<a id="60"></a><span class="comment">--- Update all Widgets
</span><span class="keyword">function</span> WidgetRenderer:update()
    <span class="keyword">if</span> self.root:update() <span class="keyword">then</span> self:layout() <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Render to the given context
</span><a id="66"></a><span class="comment">-- @tparam cairo_t cr
</span><span class="keyword">function</span> WidgetRenderer:render(cr)
    cairo_set_source_surface(cr, self._background_surface, <span class="number">0</span>, <span class="number">0</span>)
    cairo_paint(cr)
    cairo_translate(cr, self.padding, self.padding)
    self.root:render(cr)
<span class="keyword">end</span>


<span class="comment">--- Base Widget class.
</span><span class="comment">-- @type Widget
</span><span class="keyword">local</span> Widget = util.class()

<span class="comment">--- Every widget needs a height used by the layout engine to correctly position
</span><a id="80"></a><span class="comment">-- the widget.
</span>Widget.height = <span class="number">0</span>

<span class="comment">--- Called at least once to inform the widget of its width.
</span><a id="84"></a><span class="comment">-- @tparam int width
</span><span class="keyword">function</span> Widget:layout(width) <span class="keyword">end</span>

<span class="comment">--- Called at least once to allow the widget to draw static content.
</span><span class="comment">-- @tparam cairo_t cr Cairo context for background rendering
</span><a id="89"></a><span class="comment">--                    (to be cached by the WidgetRenderer)
</span><span class="keyword">function</span> Widget:render_background(cr) <span class="keyword">end</span>

<span class="comment">--- Called before each call to :render(cr).
</span><span class="comment">-- If this function returns a true-ish value, a reflow will be triggered.
</span><span class="comment">-- Since this involves calls to all widgets' :layout functions,
</span><span class="comment">-- reflows should be used sparingly.
</span><a id="96"></a><span class="comment">-- @treturn ?bool true(-ish) if a layout reflow should be triggered
</span><span class="keyword">function</span> Widget:update() <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>

<span class="comment">--- Called once per update to do draw dynamic content.
</span><a id="100"></a><span class="comment">-- @tparam cairo_t cr
</span><span class="keyword">function</span> Widget:render(cr) <span class="keyword">end</span>


<span class="comment">--- Basic collection of widgets.
</span><span class="comment">-- Grouped widgets are drawn in a vertical stack,
</span><span class="comment">-- starting at the top of the drawble surface.
</span><span class="comment">-- @type WidgetGroup
</span><span class="keyword">local</span> WidgetGroup = util.class(Widget)

<span class="comment">---
</span><a id="111"></a><span class="comment">-- @tparam {Widget,...} widgets
</span><span class="keyword">function</span> WidgetGroup:init(widgets)
    self._widgets = widgets
    self.height = <span class="number">0</span>
    <span class="keyword">for</span> _, w <span class="keyword">in</span> <span class="global">ipairs</span>(widgets) <span class="keyword">do</span>
        self.height = self.height + w.height
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> WidgetGroup:layout(width)
    self._width = width  <span class="comment">-- used to draw debug lines
</span>    <span class="keyword">for</span> _, w <span class="keyword">in</span> <span class="global">ipairs</span>(self._widgets) <span class="keyword">do</span>
        w:layout(width)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> WidgetGroup:render_background(cr)
    <span class="keyword">if</span> DEBUG <span class="keyword">then</span>
        <span class="keyword">local</span> y_offset = <span class="number">0</span>
        <span class="keyword">for</span> _, w <span class="keyword">in</span> <span class="global">ipairs</span>(self._widgets) <span class="keyword">do</span>
            cairo_rectangle(cr, <span class="number">0</span>, y_offset, self._width, w.height)
            y_offset = y_offset + w.height
        <span class="keyword">end</span>
        cairo_set_line_width(cr, <span class="number">1</span>)
        cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE)
        cairo_set_source_rgba(cr, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.33</span>)
        cairo_stroke(cr)
    <span class="keyword">end</span>

    cairo_save(cr)
    <span class="keyword">for</span> _, w <span class="keyword">in</span> <span class="global">ipairs</span>(self._widgets) <span class="keyword">do</span>
        w:render_background(cr)
        cairo_translate(cr, <span class="number">0</span>, w.height)
    <span class="keyword">end</span>
    cairo_restore(cr)
<span class="keyword">end</span>

<span class="keyword">function</span> WidgetGroup:update()
    <span class="keyword">local</span> reflow = <span class="keyword">false</span>
    <span class="keyword">for</span> _, w <span class="keyword">in</span> <span class="global">ipairs</span>(self._widgets) <span class="keyword">do</span>
        reflow = w:update() <span class="keyword">or</span> reflow
    <span class="keyword">end</span>
    <span class="keyword">return</span> reflow
<span class="keyword">end</span>

<span class="keyword">function</span> WidgetGroup:render(cr)
    cairo_save(cr)
    <span class="keyword">for</span> _, w <span class="keyword">in</span> <span class="global">ipairs</span>(self._widgets) <span class="keyword">do</span>
        w:render(cr)
        cairo_translate(cr, <span class="number">0</span>, w.height)
    <span class="keyword">end</span>
    cairo_restore(cr)
<span class="keyword">end</span>


<span class="comment">--- Leave some space between widgets.
</span><span class="comment">-- @type Gap
</span><span class="keyword">local</span> Gap = util.class(Widget)

<a id="170"></a><span class="comment">--- @int height Amount of vertical space in pixels
</span><span class="keyword">function</span> Gap:init(height)
    self.height = height
<span class="keyword">end</span>


<span class="comment">--- Draw a border on the right side of the described area.
</span><span class="comment">-- @type BorderRight
</span><span class="keyword">local</span> BorderRight = util.class(Widget)

<span class="comment">--- @tparam table args table of options
</span><span class="comment">-- @int args.x Horizontal offset of the border (=width of the framed area)
</span><a id="182"></a><span class="comment">-- @int args.height Height of the framed area
</span><span class="keyword">function</span> BorderRight:init(args)
    self._x = args.x
    self._height = args.height
<span class="keyword">end</span>

<span class="keyword">function</span> BorderRight:render_background(cr)
    cairo_save(cr)
    cairo_identity_matrix(cr)
    cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE)
    cairo_set_line_width(cr, <span class="number">1</span>)
    cairo_set_source_rgba(cr, <span class="number">0.8</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0.05</span>)
    cairo_move_to(cr, self._x - <span class="number">0.5</span>, <span class="number">0</span>)
    cairo_line_to(cr, self._x - <span class="number">0.5</span>, self._height)
    cairo_stroke(cr)
    cairo_restore(cr)
<span class="keyword">end</span>


<span class="comment">--- Draw a single line changeable of text.
</span><span class="comment">-- Use this widget for text that will be updated on each cycle.
</span><span class="comment">-- @type TextLine
</span><span class="keyword">local</span> TextLine = util.class(Widget)

<span class="comment">--- @tparam table args table of options
</span><span class="comment">-- @tparam ?string args.align "left" (default), "center" or "right"
</span><span class="comment">-- @tparam ?string args.font_family
</span><span class="comment">-- @tparam ?number args.font_size
</span><a id="210"></a><span class="comment">-- @tparam ?{number,number,number,number} args.color
</span><span class="keyword">function</span> TextLine:init(args)
    self.align = args.align <span class="keyword">or</span> <span class="string">"left"</span>
    self.font_family = args.font_family <span class="keyword">or</span> default_font_family
    self.font_size = args.font_size <span class="keyword">or</span> default_font_size
    self.color = args.color <span class="keyword">or</span> default_text_color

    <span class="keyword">local</span> write_fns = {left = ch.write_left,
                       center = ch.write_centered,
                       right = ch.write_right}
    self._write_fn = write_fns[self.align]

    <span class="keyword">local</span> extents = ch.font_extents(self.font_family, self.font_size)
    self.height = extents.height + <span class="number">1</span>
    <span class="keyword">local</span> line_spacing = extents.height - (extents.ascent + extents.descent)
    <span class="comment">-- try to match conky's line spacing:
</span>    self._baseline_offset = extents.ascent + <span class="number">0.5</span> * line_spacing + <span class="number">1</span>
<span class="keyword">end</span>

<span class="comment">--- Update the text line to be displayed.
</span><a id="230"></a><span class="comment">-- @string text
</span><span class="keyword">function</span> TextLine:set_text(text)
    self.text = text
<span class="keyword">end</span>

<span class="keyword">function</span> TextLine:layout(width)
    <span class="keyword">if</span> self.align == <span class="string">"center"</span> <span class="keyword">then</span>
        self._x = <span class="number">0.5</span> * width
    <span class="keyword">elseif</span> self.align == <span class="string">"left"</span> <span class="keyword">then</span>
        self._x = <span class="number">0</span>
    <span class="keyword">else</span>  <span class="comment">-- self.align == "right"
</span>        self._x = width
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> TextLine:render(cr)
    cairo_select_font_face(cr, self.font_family, CAIRO_FONT_SLANT_NORMAL,
                                                 CAIRO_FONT_WEIGHT_NORMAL)
    cairo_set_font_size(cr, self.font_size)
    cairo_set_source_rgba(cr, <span class="global">unpack</span>(self.color))
    self._write_fn(cr, self._x, self._baseline_offset, self.text)
<span class="keyword">end</span>


<span class="comment">--- Progress-bar like box, similar to conky's bar.
</span><span class="comment">-- Can have small and big ticks for visual clarity,
</span><span class="comment">-- and a unit (static, up to 3 characters) written behind the end.
</span><span class="comment">-- @type Bar
</span><span class="keyword">local</span> Bar = util.class(Widget)

<span class="comment">--- @tparam table args table of options
</span><span class="comment">-- @tparam ?{number,...} args.ticks relative offsets (between 0 and 1) of ticks
</span><span class="comment">-- @tparam ?{int,...} args.big_ticks indexes of ticks to be drawn longer
</span><span class="comment">-- @tparam ?int args.thickness vertical size of the bar
</span><span class="comment">-- @tparam ?string args.unit to be drawn behind the bar - 3 characters will fit
</span><a id="265"></a><span class="comment">-- @tparam ?{number,number,number,number} args.color
</span><span class="keyword">function</span> Bar:init(args)
    self.ticks = args.ticks
    self.big_ticks = args.big_ticks
    self.unit = args.unit
    self.thickness = args.thickness <span class="keyword">or</span> <span class="number">5</span>
    self.color = args.color <span class="keyword">or</span> default_graph_color

    self.height = self.thickness
    <span class="keyword">if</span> self.ticks <span class="keyword">then</span>
        self.height = self.height + (self.big_ticks <span class="keyword">and</span> <span class="number">5</span> <span class="keyword">or</span> <span class="number">4</span>)
    <span class="keyword">end</span>
    <span class="keyword">if</span> self.unit <span class="keyword">then</span>
        self.height = <span class="global">math</span>.max(self.height, <span class="number">8</span>)  <span class="comment">-- line_height
</span>    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> Bar:layout(width)
    self._width = width - (self.unit <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">or</span> <span class="number">0</span>)

    self._ticks = {}
    <span class="keyword">if</span> self.ticks <span class="keyword">then</span>
        <span class="keyword">local</span> x, tick_length
        <span class="keyword">for</span> i, frac <span class="keyword">in</span> <span class="global">ipairs</span>(self.ticks) <span class="keyword">do</span>
            x = <span class="global">math</span>.floor(frac * self._width) + <span class="number">0.5</span>
            tick_length = <span class="number">3</span>
            <span class="keyword">if</span> self.big_ticks <span class="keyword">then</span>
                <span class="keyword">if</span> self.big_ticks[i] <span class="keyword">then</span>
                    tick_length = <span class="number">4</span>
                <span class="keyword">else</span>
                    tick_length = <span class="number">2</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="global">table</span>.insert(self._ticks, {x, self.thickness + <span class="number">0.5</span>, tick_length})
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> Bar:render_background(cr)
    <span class="keyword">if</span> self.unit <span class="keyword">then</span>
        ch.font_normal(cr)
        cairo_set_source_rgba(cr, <span class="global">unpack</span>(default_text_color))
        ch.write_left(cr, self._width + <span class="number">5</span>, <span class="number">6</span>, self.unit)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Set the fill-ratio of the bar
</span><a id="312"></a><span class="comment">-- @number fraction between 0 and 1
</span><span class="keyword">function</span> Bar:set_fill(fraction)
    self.fraction = fraction
<span class="keyword">end</span>

<span class="keyword">function</span> Bar:render(cr)
    <span class="keyword">local</span> r, g, b = <span class="global">unpack</span>(self.color)
    cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE)
    cairo_rectangle(cr, <span class="number">0</span>, <span class="number">0</span>, self._width, self.thickness)
    ch.alpha_gradient(cr, <span class="number">0</span>, <span class="number">0</span>, self._width, <span class="number">0</span>, r, g, b, {
        self.fraction - <span class="number">0.33</span>, <span class="number">0.33</span>,
        self.fraction - <span class="number">0.08</span>, <span class="number">0.66</span>,
        self.fraction - <span class="number">0.01</span>, <span class="number">0.75</span>,
        self.fraction, <span class="number">1</span>,
        self.fraction + <span class="number">0.01</span>,  <span class="number">0.2</span>,
        self.fraction + <span class="number">0.1</span>,  <span class="number">0.1</span>,
        <span class="number">1</span>, <span class="number">0.15</span>,
    })
    cairo_fill_preserve(cr)

    cairo_set_line_width(cr, <span class="number">1</span>)

    <span class="comment">--- fake shadow border ---
</span>    cairo_set_source_rgba(cr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">66</span>)
    cairo_stroke(cr)

    <span class="comment">--- border ---
</span>    cairo_rectangle(cr, <span class="number">1</span>, <span class="number">1</span>, self._width - <span class="number">2</span>, self.thickness - <span class="number">2</span>)
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">2</span>)
    cairo_stroke(cr)

    <span class="comment">--- ticks ---
</span>    <span class="keyword">for</span> _, tick <span class="keyword">in</span> <span class="global">ipairs</span>(self._ticks) <span class="keyword">do</span>
        cairo_move_to(cr, tick[<span class="number">1</span>], tick[<span class="number">2</span>])
        cairo_rel_line_to(cr, <span class="number">0</span>, tick[<span class="number">3</span>])
    <span class="keyword">end</span>
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">5</span>)
    cairo_stroke(cr)
<span class="keyword">end</span>


<span class="comment">--- Specialized unit-based Bar.
</span><span class="comment">-- @type MemoryBar
</span><span class="keyword">local</span> MemoryBar = util.class(Bar)

<span class="comment">--- @tparam table args table of options
</span><span class="comment">-- @tparam number args.total Total amount of memory to be represented by this bar
</span><span class="comment">-- @tparam ?string args.unit (default: "GiB")
</span><a id="360"></a><span class="comment">-- @tparam ?{number,number,number,number} args.color
</span><span class="keyword">function</span> MemoryBar:init(args)
    <span class="keyword">local</span> total = args.total
    <span class="keyword">local</span> ticks = util.range(<span class="number">1</span> / total, <span class="global">math</span>.floor(total) / total, <span class="number">1</span> / total)
    <span class="comment">-- ticks = util.range(1/16, 15/16, 1/16)
</span>    Bar.init(self, {ticks=ticks, unit=args.unit <span class="keyword">or</span> <span class="string">"GiB"</span>, color=args.color})

    self.total = <span class="global">math</span>.ceil(total)
    <span class="keyword">if</span> self.total &gt; <span class="number">8</span> <span class="keyword">then</span>
        self.big_ticks = {}
        <span class="keyword">for</span> offset = <span class="number">4</span>, self.total, <span class="number">4</span> <span class="keyword">do</span>
            self.big_ticks[offset] = offset
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Set the amount of used memory as an absolute value.
</span><a id="377"></a><span class="comment">-- @number used should be between 0 and args.total
</span><span class="keyword">function</span> MemoryBar:set_used(used)
    Bar:set_fill(used / self.total)
<span class="keyword">end</span>


<span class="comment">--- Track changing data; similar to conky's graphs.
</span><span class="comment">-- @type Graph
</span><span class="keyword">local</span> Graph = util.class(Widget)

<span class="comment">--- @tparam table args table of options
</span><span class="comment">-- @tparam number args.max maximum expected value to be represented;
</span><span class="comment">--                         may be expanded automatically as need arises
</span><span class="comment">-- @tparam ?int args.data_points how many values to store (default: 90)
</span><span class="comment">-- @tparam ?int args.height (default: 20)
</span><span class="comment">-- @tparam ?bool args.upside_down draw graph from top to bottom
</span><a id="393"></a><span class="comment">-- @tparam ?{number,number,number,number} args.color
</span><span class="keyword">function</span> Graph:init(args)
    self.max = args.max
    self.height = args.height <span class="keyword">or</span> <span class="number">20</span>
    self.upside_down = args.upside_down
    self.data = util.CycleQueue(args.data_points <span class="keyword">or</span> <span class="number">90</span>)
    self.color = args.color <span class="keyword">or</span> default_graph_color
<span class="keyword">end</span>

<span class="keyword">function</span> Graph:layout(width)
    self.width = width
    self.x_scale = <span class="number">1</span> / self.data.length * width
    self.y_scale = <span class="number">1</span> / self.max * self.height
    <span class="keyword">if</span> self.upside_down <span class="keyword">then</span>
        self.y_scale = -self.y_scale
        self.y_start = -<span class="number">0.5</span>
    <span class="keyword">else</span>
        self.y_start = self.height - <span class="number">0.5</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> Graph:render_background(cr)
    <span class="keyword">local</span> r, g, b = <span class="global">unpack</span>(self.color)
    cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE)
    cairo_set_line_width(cr, <span class="number">1</span>)

    <span class="comment">--- background shadow ---
</span>    cairo_rectangle(cr, -<span class="number">1</span>, -<span class="number">1</span>, self.width + <span class="number">2</span>, self.height + <span class="number">2</span>)
    cairo_set_source_rgba(cr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">33</span>)
    cairo_stroke(cr)

    <span class="comment">--- background ---
</span>    cairo_rectangle(cr, <span class="number">0</span>, <span class="number">0</span>, self.width, self.height)
    ch.alpha_gradient(cr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, self.height, r, g, b, {
        .<span class="number">1</span>, .<span class="number">14</span>, .<span class="number">1</span>, .<span class="number">06</span>, .<span class="number">2</span>, .<span class="number">06</span>, .<span class="number">2</span>, .<span class="number">14</span>,
        .<span class="number">3</span>, .<span class="number">14</span>, .<span class="number">3</span>, .<span class="number">06</span>, .<span class="number">4</span>, .<span class="number">06</span>, .<span class="number">4</span>, .<span class="number">14</span>,
        .<span class="number">5</span>, .<span class="number">14</span>, .<span class="number">5</span>, .<span class="number">06</span>, .<span class="number">6</span>, .<span class="number">06</span>, .<span class="number">6</span>, .<span class="number">14</span>,
        .<span class="number">7</span>, .<span class="number">14</span>, .<span class="number">7</span>, .<span class="number">06</span>, .<span class="number">8</span>, .<span class="number">06</span>, .<span class="number">8</span>, .<span class="number">14</span>,
        .<span class="number">9</span>, .<span class="number">14</span>, .<span class="number">9</span>, .<span class="number">06</span>,
    })
    cairo_fill_preserve(cr)
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">2</span>)
    cairo_stroke(cr)
<span class="keyword">end</span>

<span class="comment">--- Append the latest value to be shown - this will displace the oldest value
</span><span class="comment">-- @number value if value &gt; args.max then the graphs vertical scale will be
</span><a id="440"></a><span class="comment">--               adjusted, causing it to get squished
</span><span class="keyword">function</span> Graph:add_value(value)
    self.data:put(value)
    <span class="keyword">if</span> value &gt; self.max <span class="keyword">then</span>
        self.max = value
        self:layout(self.width)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> Graph:render(cr)
    <span class="keyword">local</span> r, g, b = <span class="global">unpack</span>(self.color)
    cairo_set_antialias(cr, CAIRO_ANTIALIAS_DEFAULT)

    cairo_move_to(cr, <span class="number">0</span>, self.y_start)
    <span class="keyword">local</span> current_max = <span class="number">0</span>
    self.data:each(<span class="keyword">function</span>(val, idx)
        cairo_line_to(cr, (idx - <span class="number">1</span>) * self.x_scale, self.y_start - val * self.y_scale)
        <span class="keyword">if</span> val &gt; current_max <span class="keyword">then</span> current_max = val <span class="keyword">end</span>
    <span class="keyword">end</span>)
    cairo_line_to(cr, self.width, self.y_start)
    cairo_set_source_rgba(cr, r, g, b, <span class="number">1</span>)
    cairo_set_line_width(cr, .<span class="number">5</span>)
    cairo_stroke_preserve(cr)

    <span class="comment">--- fill under graph ---
</span>    ch.alpha_gradient(cr, <span class="number">0</span>, self.y_start - current_max * self.y_scale,
                       <span class="number">0</span>, self.y_start,
                       r, g, b, {<span class="number">0</span>, .<span class="number">66</span>, .<span class="number">5</span>, .<span class="number">33</span>, <span class="number">1</span>, .<span class="number">25</span>})
    cairo_fill(cr)
<span class="keyword">end</span>


<span class="comment">--- Polygon-style CPU usage &amp; temperature tracking.
</span><span class="comment">-- Looks best for CPUs with 4 to 8 cores but also works for higher numbers
</span><span class="comment">-- @type Cpu
</span><span class="keyword">local</span> Cpu = util.class(Widget)

<span class="comment">--- @tparam table args table of options
</span><span class="comment">-- @int args.cores How many cores does your CPU have?
</span><span class="comment">-- @int args.scale radius of central polygon
</span><span class="comment">-- @int args.gap space between central polygon and outer segments
</span><a id="481"></a><span class="comment">-- @int args.segment_size radial thickness of outer segments
</span><span class="keyword">function</span> Cpu:init(args)
    self.cores = args.cores
    self.scale = args.scale
    self.gap = args.gap
    self.segment_size = args.segment_size
<span class="keyword">end</span>

<span class="keyword">function</span> Cpu:layout(width)
    <span class="keyword">local</span> radius = self.scale + self.gap + self.segment_size
    self.height = <span class="number">2</span> * radius
    self.mx = width / <span class="number">2</span>
    self.my = radius

    self.center_coordinates = {}
    self.segment_coordinates = {}
    self.gradient_coordinates = {}
    <span class="keyword">local</span> sector_rad = <span class="number">2</span> * <span class="global">math</span>.pi / self.cores
    <span class="keyword">local</span> min, max = self.scale + self.gap, radius

    <span class="keyword">for</span> core = <span class="number">1</span>, self.cores <span class="keyword">do</span>
        <span class="keyword">local</span> rad_center = (core - <span class="number">1</span>) * sector_rad - <span class="global">math</span>.pi/<span class="number">2</span>
        <span class="keyword">local</span> rad_left = rad_center + sector_rad/<span class="number">2</span>
        <span class="keyword">local</span> rad_right = rad_center - sector_rad/<span class="number">2</span>
        <span class="keyword">local</span> dx_center, dy_center = <span class="global">math</span>.cos(rad_center), <span class="global">math</span>.sin(rad_center)
        <span class="keyword">local</span> dx_left, dy_left = <span class="global">math</span>.cos(rad_left), <span class="global">math</span>.sin(rad_left)
        <span class="keyword">local</span> dx_right, dy_right = <span class="global">math</span>.cos(rad_right), <span class="global">math</span>.sin(rad_right)
        self.center_coordinates[<span class="number">2</span> * core - <span class="number">1</span>] = self.mx + self.scale * dx_left
        self.center_coordinates[<span class="number">2</span> * core] = self.my + self.scale * dy_left

        <span class="comment">-- segment corners
</span>        <span class="keyword">local</span> dx_gap, dy_gap = self.gap * dx_center, self.gap * dy_center
        <span class="keyword">local</span> x1 = self.mx + min * dx_left + dx_gap
        <span class="keyword">local</span> y1 = self.my + min * dy_left + dy_gap
        <span class="keyword">local</span> x2 = self.mx + max * dx_left + dx_gap
        <span class="keyword">local</span> y2 = self.my + max * dy_left + dy_gap
        <span class="keyword">local</span> x3 = self.mx + max * dx_right + dx_gap
        <span class="keyword">local</span> y3 = self.my + max * dy_right + dy_gap
        <span class="keyword">local</span> x4 = self.mx + min * dx_right + dx_gap
        <span class="keyword">local</span> y4 = self.my + min * dy_right + dy_gap
        self.segment_coordinates[core] = {x1, y1, x2, y2, x3, y3, x4, y4}
        self.gradient_coordinates[core] = {(x1 + x4) / <span class="number">2</span>, (y1 + y4) / <span class="number">2</span>,
                                           (x2 + x3) / <span class="number">2</span>, (y2 + y3) / <span class="number">2</span>}
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> Cpu:update()
    self.percentages = data.cpu_percentages(self.cores)
    self.temperatures = data.cpu_temperatures()
<span class="keyword">end</span>

<span class="keyword">function</span> Cpu:render(cr)
    <span class="keyword">local</span> avg_temperature = util.avg(self.temperatures)
    <span class="keyword">local</span> r, g, b = temp_color(avg_temperature, <span class="number">30</span>, <span class="number">80</span>)

    ch.polygon(cr, self.center_coordinates)
    cairo_set_line_width(cr, <span class="number">6</span>)
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">33</span>)
    cairo_stroke_preserve(cr)
    cairo_set_line_width(cr, <span class="number">1</span>)
    cairo_set_source_rgba(cr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">66</span>)
    cairo_stroke_preserve(cr)
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">18</span>)
    cairo_fill(cr)

    cairo_select_font_face(cr, default_font_family, CAIRO_FONT_SLANT_NORMAL,
                                                    CAIRO_FONT_WEIGHT_BOLD)
    cairo_set_font_size(cr, <span class="number">16</span>)
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">4</span>)
    ch.write_middle(cr, self.mx + <span class="number">1</span>, self.my, <span class="global">string</span>.format(<span class="string">"%.0f°"</span>, avg_temperature))

    <span class="keyword">for</span> core = <span class="number">1</span>, self.cores <span class="keyword">do</span>
        ch.polygon(cr, self.segment_coordinates[core])
        <span class="keyword">local</span> gradient = cairo_pattern_create_linear(<span class="global">unpack</span>(self.gradient_coordinates[core]))
        <span class="keyword">local</span> r, g, b = temp_color(self.temperatures[core], <span class="number">30</span>, <span class="number">80</span>)
        cairo_set_source_rgba(cr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">4</span>)
        cairo_set_line_width(cr, <span class="number">1.5</span>)
        cairo_stroke_preserve(cr)
        cairo_set_source_rgba(cr, r, g, b, .<span class="number">4</span>)
        cairo_set_line_width(cr, .<span class="number">75</span>)
        cairo_stroke_preserve(cr)

        <span class="keyword">local</span> h_rel = self.percentages[core]/<span class="number">100</span>
        cairo_pattern_add_color_stop_rgba(gradient, <span class="number">0</span>,            r, g, b, .<span class="number">33</span>)
        cairo_pattern_add_color_stop_rgba(gradient, h_rel - .<span class="number">045</span>, r, g, b, .<span class="number">75</span>)
        cairo_pattern_add_color_stop_rgba(gradient, h_rel,
                                          r * <span class="number">1.2</span>, g * <span class="number">1.2</span>, b * <span class="number">1.2</span>, <span class="number">1</span>)
        <span class="keyword">if</span> h_rel &lt; .<span class="number">95</span> <span class="keyword">then</span>  <span class="comment">-- prevent pixelated edge
</span>            cairo_pattern_add_color_stop_rgba(gradient, h_rel + .<span class="number">045</span>, r, g, b, .<span class="number">33</span>)
            cairo_pattern_add_color_stop_rgba(gradient, h_rel + .<span class="number">33</span>,  r, g, b, .<span class="number">15</span>)
            cairo_pattern_add_color_stop_rgba(gradient, <span class="number">1</span>,            r, g, b, .<span class="number">15</span>)
        <span class="keyword">end</span>
        cairo_set_source(cr, gradient)
        cairo_pattern_destroy(gradient)
        cairo_fill(cr)
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">--- Visualize cpu-frequencies in a style reminiscent of stacked progress bars.
</span><span class="comment">-- @type CpuFrequencies
</span><span class="keyword">local</span> CpuFrequencies = util.class(Widget)

<span class="comment">--- @tparam table args table of options
</span><span class="comment">-- @int args.cores How many cores does your CPU have?
</span><span class="comment">-- @number args.min_freq What is your CPU's minimum frequency?
</span><span class="comment">-- @number args.min_freq What is your CPU's maximum frequency?
</span><a id="588"></a><span class="comment">-- @tparam ?int args.height Maximum pixel height of the drawn shape (default: 16)
</span><span class="keyword">function</span> CpuFrequencies:init(args)
    self.cores = args.cores
    self.min_freq = args.min_freq
    self.max_freq = args.max_freq
    self._height = args.height <span class="keyword">or</span> <span class="number">16</span>
    self.height = self._height + <span class="number">10</span>
<span class="keyword">end</span>

<span class="keyword">function</span> CpuFrequencies:layout(width)
    self._width = width - <span class="number">25</span>
    self._polygon_coordinates = {
        <span class="number">0</span>, self._height * (<span class="number">1</span> - self.min_freq / self.max_freq),
        self._width, <span class="number">0</span>,
        self._width, self._height,
        <span class="number">0</span>, self._height,
    }
    self._ticks = {}
    self._tick_labels = {}

    <span class="keyword">local</span> df = self.max_freq - self.min_freq
    <span class="keyword">for</span> freq = <span class="number">1</span>, self.max_freq, .<span class="number">25</span> <span class="keyword">do</span>
        <span class="keyword">local</span> x = self._width * (freq - self.min_freq) / df
        <span class="keyword">local</span> big = <span class="global">math</span>.floor(freq) == freq
        <span class="keyword">if</span> big <span class="keyword">then</span>
            <span class="global">table</span>.insert(self._tick_labels, {x, self._height + <span class="number">10.5</span>, (<span class="string">"%.0f"</span>):format(freq)})
        <span class="keyword">end</span>
        <span class="global">table</span>.insert(self._ticks, {<span class="global">math</span>.floor(x) + .<span class="number">5</span>,
                                   self._height + <span class="number">1.5</span>,
                                   big <span class="keyword">and</span> <span class="number">3</span> <span class="keyword">or</span> <span class="number">2</span>})
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> CpuFrequencies:render_background(cr)
    ch.font_normal(cr)
    cairo_set_source_rgba(cr, <span class="global">unpack</span>(default_text_color))
    ch.write_left(cr, self._width + <span class="number">5</span>, <span class="number">0.5</span> * self._height + <span class="number">3</span>, <span class="string">"GHz"</span>)

    <span class="comment">-- shadow outline
</span>    ch.polygon(cr, {
        self._polygon_coordinates[<span class="number">1</span>] - <span class="number">1</span>, self._polygon_coordinates[<span class="number">2</span>] - <span class="number">1</span>,
        self._polygon_coordinates[<span class="number">3</span>] + <span class="number">1</span>, self._polygon_coordinates[<span class="number">4</span>] - <span class="number">1</span>,
        self._polygon_coordinates[<span class="number">5</span>] + <span class="number">1</span>, self._polygon_coordinates[<span class="number">6</span>] + <span class="number">1</span>,
        self._polygon_coordinates[<span class="number">7</span>] - <span class="number">1</span>, self._polygon_coordinates[<span class="number">8</span>] + <span class="number">1</span>,
    })
    cairo_set_source_rgba(cr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">4</span>)
    cairo_set_line_width(cr, <span class="number">1</span>)
    cairo_stroke(cr)
<span class="keyword">end</span>

<span class="keyword">function</span> CpuFrequencies:update()
    self.frequencies = data.cpu_frequencies(self.cores)
    self.temperatures = data.cpu_temperatures()
<span class="keyword">end</span>

<span class="keyword">function</span> CpuFrequencies:render(cr)
    <span class="keyword">local</span> r, g, b = temp_color(util.avg(self.temperatures), <span class="number">30</span>, <span class="number">80</span>)
    cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE)
    cairo_set_line_width(cr, <span class="number">1</span>)

    <span class="comment">-- ticks --
</span>    cairo_set_source_rgba(cr, r, g, b, .<span class="number">66</span>)
    <span class="keyword">for</span> _, tick <span class="keyword">in</span> <span class="global">ipairs</span>(self._ticks) <span class="keyword">do</span>
        cairo_move_to(cr, tick[<span class="number">1</span>], tick[<span class="number">2</span>])
        cairo_rel_line_to(cr, <span class="number">0</span>, tick[<span class="number">3</span>])
    <span class="keyword">end</span>
    cairo_stroke(cr)
    ch.font_normal(cr)
    <span class="keyword">for</span> _, label <span class="keyword">in</span> <span class="global">ipairs</span>(self._tick_labels) <span class="keyword">do</span>
        ch.write_centered(cr, label[<span class="number">1</span>], label[<span class="number">2</span>], label[<span class="number">3</span>])
    <span class="keyword">end</span>

    <span class="comment">-- background --
</span>    ch.polygon(cr, self._polygon_coordinates)
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">15</span>)
    cairo_fill_preserve(cr)
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">3</span>)
    cairo_stroke_preserve(cr)

    <span class="comment">-- frequencies --
</span>    <span class="keyword">local</span> df = self.max_freq - self.min_freq
    <span class="keyword">for</span> _, frequency <span class="keyword">in</span> <span class="global">ipairs</span>(self.frequencies) <span class="keyword">do</span>
        <span class="keyword">local</span> stop = (frequency - self.min_freq) / df
        ch.alpha_gradient(cr, <span class="number">0</span>, <span class="number">0</span>, self._width, <span class="number">0</span>, r, g, b, {
             <span class="number">0</span>, <span class="number">0.01</span>,
             stop - .<span class="number">4</span>, <span class="number">0.015</span>,
             stop - .<span class="number">2</span>, <span class="number">0.05</span>,
             stop - .<span class="number">1</span>, <span class="number">0.1</span>,
             stop - .<span class="number">02</span>, <span class="number">0.2</span>,
             stop, <span class="number">0.6</span>,
             stop, <span class="number">0</span>,
        })
        cairo_fill_preserve(cr)
    <span class="keyword">end</span>
    cairo_new_path(cr)
<span class="keyword">end</span>


<span class="comment">--- Visualize memory usage in a randomized grid.
</span><span class="comment">-- Does not represent actual distribution of used memory.
</span><span class="comment">-- Also shows buffere/cache memory at reduced brightness.
</span><span class="comment">-- @type MemoryGrid
</span><span class="keyword">local</span> MemoryGrid = util.class(Widget)

<span class="comment">--- @tparam table args table of options
</span><span class="comment">-- @int args.rows number of rows to draw
</span><span class="comment">-- @int args.columns number of columns to draw
</span><span class="comment">-- @tparam ?int args.point_size edge length of individual squares
</span><span class="comment">-- @tparam ?int args.gap space between squares
</span><a id="697"></a><span class="comment">-- @tparam ?bool args.shuffle randomize? (default: true)
</span><span class="keyword">function</span> MemoryGrid:init(args)
    self.rows = args.rows
    self.columns = args.columns
    self.point_size = args.point_size <span class="keyword">or</span> <span class="number">2</span>
    self.gap = args.gap <span class="keyword">or</span> <span class="number">1</span>
    self.shuffle = args.shuffle == <span class="keyword">nil</span> <span class="keyword">and</span> <span class="keyword">true</span> <span class="keyword">or</span> args.shuffle
    self.height = self.rows * self.point_size + (self.rows - <span class="number">1</span>) * self.gap
<span class="keyword">end</span>

<span class="keyword">function</span> MemoryGrid:layout(width)
    self.coordinates = {}
    <span class="keyword">local</span> point_plus_gap = self.point_size + self.gap
    <span class="keyword">for</span> col = <span class="number">0</span>, self.columns - <span class="number">1</span>, <span class="number">1</span> <span class="keyword">do</span>
        <span class="keyword">for</span> row = <span class="number">0</span>, self.rows - <span class="number">1</span>, <span class="number">1</span> <span class="keyword">do</span>
            <span class="global">table</span>.insert(self.coordinates, {col * point_plus_gap,
                                            row * point_plus_gap,
                                            self.point_size, self.point_size})
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> shuffle == <span class="keyword">nil</span> <span class="keyword">or</span> shuffle <span class="keyword">then</span>
        util.shuffle(self.coordinates)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> MemoryGrid:update()
    self.used, self.easyfree, self.free, self.total = data.memory()
<span class="keyword">end</span>

<span class="keyword">function</span> MemoryGrid:render(cr)
    <span class="keyword">local</span> total_points = #self.coordinates
    <span class="keyword">local</span> used_points = <span class="global">math</span>.floor(total_points * self.used / self.total + <span class="number">0.5</span>)
    <span class="keyword">local</span> cache_points = <span class="global">math</span>.floor(total_points * (self.easyfree - self.free) / self.total + <span class="number">0.5</span>)
    <span class="keyword">local</span> r, g, b = <span class="global">unpack</span>(default_graph_color)  <span class="comment">-- TODO color manager
</span>
    <span class="keyword">if</span> self.used / self.total &gt; <span class="number">0.7</span> <span class="keyword">then</span>
        <span class="keyword">if</span> self.used / self.total &gt; <span class="number">0.85</span> <span class="keyword">then</span>
            r, g, b = <span class="global">unpack</span>(temperature_colors[#temperature_colors])
        <span class="keyword">else</span>
            r, g, b = <span class="global">unpack</span>(temperature_colors[#temperature_colors - <span class="number">1</span>])
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE)
    <span class="keyword">for</span> i = <span class="number">1</span>, used_points <span class="keyword">do</span>
        cairo_rectangle(cr, <span class="global">unpack</span>(self.coordinates[i]))
    <span class="keyword">end</span>
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">8</span>)
    cairo_fill(cr)
    <span class="keyword">for</span> i = used_points, used_points + cache_points <span class="keyword">do</span>
        cairo_rectangle(cr, <span class="global">unpack</span>(self.coordinates[i]))
    <span class="keyword">end</span>
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">35</span>)
    cairo_fill(cr)
    <span class="keyword">for</span> i = used_points + cache_points, total_points <span class="keyword">do</span>
        cairo_rectangle(cr, <span class="global">unpack</span>(self.coordinates[i]))
    <span class="keyword">end</span>
    cairo_set_source_rgba(cr, r, g, b, .<span class="number">1</span>)
    cairo_fill(cr)
<span class="keyword">end</span>


<span class="comment">--- Compound widget to display GPU and VRAM usage.
</span><span class="comment">-- @type Gpu
</span><span class="keyword">local</span> Gpu = util.class(WidgetGroup)

<a id="763"></a><span class="comment">--- no options
</span><span class="keyword">function</span> Gpu:init()
    self.usebar = Bar{ticks={.<span class="number">25</span>, .<span class="number">5</span>, .<span class="number">75</span>}, unit=<span class="string">"%"</span>}
    <span class="keyword">local</span> _, mem_total = data.gpu_memory()
    self.membar = MemoryBar{total=mem_total / <span class="number">1024</span>}
    WidgetGroup.init(self, {self.usebar, Gap(<span class="number">4</span>), self.membar})
<span class="keyword">end</span>

<span class="keyword">function</span> Gpu:update()
    self.usebar:set_fill(data.gpu_percentage() / <span class="number">100</span>)

    <span class="keyword">local</span> mem_used, _ = data.gpu_memory()
    self.membar:set_used(mem_used / <span class="number">1024</span>)

    <span class="keyword">local</span> color = util.pack(temp_color(data.gpu_temperature(), <span class="number">30</span>, <span class="number">80</span>))
    self.usebar.color = color
    self.membar.color = color
<span class="keyword">end</span>

<span class="comment">--- Table of processes for the GPU, sorted by VRAM usage
</span><span class="comment">-- @type GpuTop
</span><span class="keyword">local</span> GpuTop = util.class(Widget)

<span class="comment">--- @tparam table args table of options
</span><span class="comment">-- @tparam ?int args.lines how many processes to display
</span><span class="comment">-- @tparam ?string args.font_family
</span><span class="comment">-- @tparam ?number args.font_size
</span><a id="790"></a><span class="comment">-- @tparam ?{number,number,number,number} args.color
</span><span class="keyword">function</span> GpuTop:init(args)
    self._lines = args.lines <span class="keyword">or</span> <span class="number">5</span>
    self._font_family = args.font_family <span class="keyword">or</span> default_font_family
    self._font_size = args.font_size <span class="keyword">or</span> default_font_size
    self._color = args.color <span class="keyword">or</span> default_text_color

    <span class="keyword">local</span> extents = ch.font_extents(self._font_family, self._font_size)
    self._line_height = extents.height
    self.height = self._lines * self._line_height
    <span class="keyword">local</span> line_spacing = extents.height - (extents.ascent + extents.descent)
    <span class="comment">-- try to match conky's line spacing:
</span>    self._baseline_offset = extents.ascent + <span class="number">0.5</span> * line_spacing + <span class="number">1</span>
<span class="keyword">end</span>

<span class="keyword">function</span> GpuTop:layout(width)
    self._width = width
<span class="keyword">end</span>

<span class="keyword">function</span> GpuTop:update()
    self._processes = data.gpu_top()
<span class="keyword">end</span>

<span class="keyword">function</span> GpuTop:render(cr)
    cairo_select_font_face(cr, self._font_family, CAIRO_FONT_SLANT_NORMAL,
                                                 CAIRO_FONT_WEIGHT_NORMAL)
    cairo_set_font_size(cr, self._font_size)
    cairo_set_source_rgba(cr, <span class="global">unpack</span>(self._color))
    cairo_set_antialias(cr, CAIRO_ANTIALIAS_NONE)

    <span class="keyword">local</span> lines = <span class="global">math</span>.min(self._lines, #self._processes)
    <span class="keyword">local</span> y = self._baseline_offset
    <span class="keyword">for</span> i = <span class="number">1</span>, lines <span class="keyword">do</span>
        ch.write_left(cr, <span class="number">0</span>, y, self._processes[i][<span class="number">1</span>])
        ch.write_right(cr, self._width, y, self._processes[i][<span class="number">2</span>] .. <span class="string">" MiB"</span>)
        y = y + self._line_height
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Graphs for up- and download speed.
</span><span class="comment">-- This widget assumes that your conky.text adds some text between the graphs.
</span><span class="comment">-- @type Network
</span><span class="keyword">local</span> Network = util.class(WidgetGroup)

<span class="comment">--- @tparam table args table of options
</span><span class="comment">-- @string args.interface e.g. "eth0"
</span><span class="comment">-- @tparam ?int args.graph_height passed to Graph:init
</span><span class="comment">-- @tparam ?number args.downspeed passed as args.max to download speed graph
</span><a id="838"></a><span class="comment">-- @tparam ?number args.upspeed passed as args.max to upload speed graph
</span><span class="keyword">function</span> Network:init(args)
    self.interface = args.interface
    self.downspeed_graph = Graph{height=args.graph_height, max=args.downspeed <span class="keyword">or</span> <span class="number">1024</span>}
    self.upspeed_graph = Graph{height=args.graph_height, max=args.upspeed <span class="keyword">or</span> <span class="number">1024</span>}
    WidgetGroup.init(self, {self.downspeed_graph, Gap(<span class="number">33</span>), self.upspeed_graph})
<span class="keyword">end</span>

<span class="keyword">function</span> Network:update()
    <span class="keyword">local</span> down, up = data.network_speed(self.interface)
    self.downspeed_graph:add_value(down)
    self.upspeed_graph:add_value(up)
<span class="keyword">end</span>

<span class="comment">--- Visualize drive usage and temperature in a colorized Bar.
</span><span class="comment">-- Also writes temperature as text.
</span><span class="comment">-- This widget is exptected to be combined with some special conky.text.
</span><span class="comment">-- @type Drive
</span><span class="keyword">local</span> Drive = util.class(WidgetGroup)

<span class="comment">---
</span><span class="comment">-- @string path e.g. "/home"
</span><a id="860"></a><span class="comment">-- @string device_name e.g. "/dev/sda1"
</span><span class="keyword">function</span> Drive:init(path, device_name)
    self.path = path
    self.device_name = device_name

    self._temperature_text = TextLine{align=<span class="string">"right"</span>}
    self._bar = Bar{}
    WidgetGroup.init(self, {self._temperature_text,
                            Gap(<span class="number">4</span>),
                            self._bar,
                            Gap(<span class="number">26</span>)})
    self._height = self.height
    self.is_mounted = data.is_mounted(self.path)
    <span class="keyword">if</span> <span class="keyword">not</span> self.is_mounted <span class="keyword">then</span>
        self.height = <span class="number">0</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> Drive:render_background(cr)
    <span class="keyword">if</span> self.is_mounted <span class="keyword">then</span>
        WidgetGroup.render_background(self, cr)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> Drive:update()
    <span class="keyword">local</span> was_mounted = self.is_mounted
    self.is_mounted = data.is_mounted(self.path)
    <span class="keyword">if</span> self.is_mounted <span class="keyword">then</span>
        self._bar:set_fill(data.drive_percentage(self.path) / <span class="number">100</span>)
        self.temperature = data.hddtemp()[self.device_name]
        self.height = self._height
    <span class="keyword">else</span>
        self.height = <span class="number">0</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> self.is_mounted ~= was_mounted
<span class="keyword">end</span>

<span class="keyword">function</span> Drive:render(cr)
    <span class="keyword">if</span> <span class="keyword">not</span> self.is_mounted <span class="keyword">then</span>
        <span class="keyword">return</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> self.temperature <span class="keyword">then</span>
        self._bar.color = {temp_color(self.temperature, <span class="number">35</span>, <span class="number">65</span>)}
        self._temperature_text:set_text(self.temperature .. <span class="string">"°C"</span>)
    <span class="keyword">else</span>
        self._bar.color = {<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>}
        self._temperature_text:set_text(<span class="string">"––––"</span>)
    <span class="keyword">end</span>
    WidgetGroup.render(self, cr)
<span class="keyword">end</span>


<span class="keyword">return</span> {
    Bar = Bar,
    BorderRight = BorderRight,
    Cpu = Cpu,
    CpuFrequencies = CpuFrequencies,
    Drive = Drive,
    Gap = Gap,
    Gpu = Gpu,
    GpuTop = GpuTop,
    Graph = Graph,
    MemoryBar = MemoryBar,
    MemoryGrid = MemoryGrid,
    Network = Network,
    TextLine = TextLine,
    Widget = Widget,
    WidgetGroup = WidgetGroup,
    WidgetRenderer = WidgetRenderer,
}</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2019-11-01 17:47:03 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
